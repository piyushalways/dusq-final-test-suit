/******************************************************************************
 * Copyright Â© 2022 ams-OSRAM AG                                              *
 * All rights are reserved.                                                   *
 *                                                                            *
 * FOR FULL LICENSE TEXT SEE LICENSE.TXT                                      *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                 INCLUDES                                   *
 ******************************************************************************/

#include "as7058_eda_app.h"

#include <math.h>

#include "fifo.h"

/******************************************************************************
 *                                DEFINITIONS                                 *
 ******************************************************************************/

/*! Checks whether the module is in the expected state and returns ::ERR_PERMISSION otherwise. */
#define M_CHECK_STATE(expected)                                                                                        \
    do {                                                                                                               \
        if (g_state != (expected)) {                                                                                   \
            return ERR_PERMISSION;                                                                                     \
        }                                                                                                              \
    } while (0)

/*! Checks whether the module is not in the expected state and returns ::ERR_PERMISSION otherwise. */
#define M_CHECK_STATE_NOT(unexpected)                                                                                  \
    do {                                                                                                               \
        if ((unexpected) == g_state) {                                                                                 \
            return ERR_PERMISSION;                                                                                     \
        }                                                                                                              \
    } while (0)

/*! Global states of the module. */
enum as7058_eda_app_state {
    AS7058_EDA_APP_STATE_UNINITIALIZED = 0, /*!< Module is in uninitialized state. */
    AS7058_EDA_APP_STATE_CONFIGURATION,     /*!< Module is in configuration state. */
    AS7058_EDA_APP_STATE_PROCESSING         /*!< Module is in processing state. */
};

/*!
 * \brief State of the signal input processing.
 *
 * This state is used by ::process_samples to generate ::as7058_eda_app_calculation_input items that are consumed by
 * ::as7058_eda_app_execute.
 */
struct as7058_eda_app_input_state {
    uint64_t eda_positive_accumulator; /*!< Accumulator used for averaging positive EDA samples. */
    uint64_t eda_negative_accumulator; /*!< Accumulator used for averaging negative EDA samples. */
    uint32_t eda_total_count;          /*!< Counter used for averaging EDA samples. This counter contains the total
                                            number of summed EDA samples, including both positive and negative samples.
                                            */
    uint32_t eda_total_drop_count;     /*!< Counter used for dropping some EDA samples. This counter contains the total
                                            number of dropped EDA samples, including both positive and negative
                                            samples. */
    uint64_t temperature_accumulator;  /*!< Accumulator used for averaging the temperature samples. */
    uint32_t temperature_count;        /*!< Counter used for averaging the temperature samples. */
};

/*!
 * \brief Calculation input containing averaged values.
 *
 * These inputs are generated by ::process_samples and are consumed by ::as7058_eda_app_execute.
 */
struct as7058_eda_app_calculation_input {
    uint32_t eda_positive;     /*! Averaged value of the positive EDA samples. */
    uint32_t eda_negative;     /*! Averaged value of the negative EDA samples. */
    uint32_t temperature;      /*! Averaged temperature in ADC counts. */
    uint8_t temperature_valid; /*! ::TRUE if the temperature value is valid, ::FALSE otherwise. */
};

#ifndef AS7058_EDA_APP_INPUT_QUEUE_CAPACITY
/*! Number of items the calculation inputs FIFO queue can hold. */
#define AS7058_EDA_APP_INPUT_QUEUE_CAPACITY 3
#endif /* AS7058_EDA_APP_INPUT_QUEUE_CAPACITY */

#ifndef AS7058_EDA_APP_OUTPUT_QUEUE_CAPACITY
/*! Number of items the application outputs FIFO queue can hold. */
#define AS7058_EDA_APP_OUTPUT_QUEUE_CAPACITY 3
#endif /* AS7058_EDA_APP_OUTPUT_QUEUE_CAPACITY */

/******************************************************************************
 *                                  GLOBALS                                   *
 ******************************************************************************/

/*! Current global state of the module. */
static volatile enum as7058_eda_app_state g_state = AS7058_EDA_APP_STATE_UNINITIALIZED;

/*! Current configuration of the application. */
static as7058_eda_app_configuration_t g_config;

/*! ::TRUE when ::g_config contains a valid value, ::FALSE otherwise. */
static uint8_t g_config_valid;

/*! Current state of the input. */
static struct as7058_eda_app_input_state g_input_state;

/*! Last averaged temperature in ADC counts that was used for EDA calculation. */
static uint32_t g_last_temperature;

/*! ::TRUE when ::g_config contains a valid value, ::FALSE otherwise. */
static uint8_t g_last_temperature_valid;

/*! Buffer used by ::g_input_queue. */
static volatile struct as7058_eda_app_calculation_input g_input_queue_buf[AS7058_EDA_APP_INPUT_QUEUE_CAPACITY + 1];

/*! FIFO queue containing EDA calculation inputs. */
static volatile fifo_t g_input_queue = {
    .itemsize = sizeof(g_input_queue_buf[0]),
    .capacity = AS7058_EDA_APP_INPUT_QUEUE_CAPACITY + 1,
    .in = 0,
    .out = 0,
    .data = (void *)g_input_queue_buf,
};

/*! Buffer used by ::g_output_queue. */
static volatile as7058_eda_app_output_t g_output_queue_buf[AS7058_EDA_APP_OUTPUT_QUEUE_CAPACITY + 1];

/*! FIFO queue containing application output payloads, i.e. EDA calculation results. */
static volatile fifo_t g_output_queue = {
    .itemsize = sizeof(g_output_queue_buf[0]),
    .capacity = AS7058_EDA_APP_OUTPUT_QUEUE_CAPACITY + 1,
    .in = 0,
    .out = 0,
    .data = (void *)g_output_queue_buf,
};

/******************************************************************************
 *                               LOCAL FUNCTIONS                              *
 ******************************************************************************/

/*!
 * \brief Feeds samples into a ::as7058_eda_app_input_state instance and generates ::as7058_eda_app_calculation_input
 *        items. The calculation inputs are added to the provided queue.
 */
static err_code_t process_samples(struct as7058_eda_app_input_state *p_input_state,
                                  bio_signal_samples_t eda_signal_samples,
                                  bio_signal_samples_t temperature_signal_samples, uint32_t samples_to_average_num,
                                  uint32_t samples_to_drop_num, fifo_t *p_queue)
{
    /* Add all temperature samples that have been passed to the function to the current input state. No attempt is made
     * to determine which temperature samples temporally belong to which EDA samples. */
    uint64_t temperature_samples_sum = 0;
    for (unsigned int i = 0; i < temperature_signal_samples.count; i++) {
        temperature_samples_sum += (uint64_t)temperature_signal_samples.samples.p_i32[i];
    }
    p_input_state->temperature_accumulator += temperature_samples_sum;
    p_input_state->temperature_count += temperature_signal_samples.count;

    unsigned int eda_signal_samples_index = 0;

    while (eda_signal_samples_index < eda_signal_samples.count) {
        /* samples_to_drop_num and samples_to_average_num are multiplied by two as they contain the number of
         * positive/negative samples to average or drop, while the counters contain the combined number of samples
         * (positive and negative). */
        if (p_input_state->eda_total_drop_count < samples_to_drop_num * 2) {
            /* Drop sample. */
            p_input_state->eda_total_drop_count++;
            eda_signal_samples_index++;
        } else {
            uint8_t is_eda_positive_sample = (p_input_state->eda_total_count % 2) ? FALSE : TRUE;
            uint64_t sample = (uint64_t)eda_signal_samples.samples.p_i32[eda_signal_samples_index];

            /* Add the EDA sample to the corresponding accumulator of the input state. */
            if (is_eda_positive_sample) {
                p_input_state->eda_positive_accumulator += sample;
            } else {
                p_input_state->eda_negative_accumulator += sample;
            }
            p_input_state->eda_total_count++;
            eda_signal_samples_index++;

            if (!is_eda_positive_sample && samples_to_average_num * 2 == p_input_state->eda_total_count) {
                /* Create calculation input if enough samples have been received for averaging. */
                uint32_t samples_per_accumulator = p_input_state->eda_total_count / 2;
                struct as7058_eda_app_calculation_input calculation_input;
                calculation_input.eda_positive =
                    (uint32_t)(p_input_state->eda_positive_accumulator / samples_per_accumulator);
                calculation_input.eda_negative =
                    (uint32_t)(p_input_state->eda_negative_accumulator / samples_per_accumulator);
                if (p_input_state->temperature_count > 0) {
                    calculation_input.temperature =
                        (uint32_t)(p_input_state->temperature_accumulator / p_input_state->temperature_count);
                    calculation_input.temperature_valid = TRUE;
                } else {
                    calculation_input.temperature = 0;
                    calculation_input.temperature_valid = FALSE;
                }
                M_CHECK_SUCCESS(FIFO_Put(p_queue, &calculation_input));

                /* Reset input state. */
                p_input_state->eda_positive_accumulator = 0;
                p_input_state->eda_negative_accumulator = 0;
                p_input_state->eda_total_count = 0;
                p_input_state->eda_total_drop_count = 0;
                if (eda_signal_samples_index < eda_signal_samples.count) {
                    /* There are further EDA samples that have been passed to this function and still need to be
                     * processed. Since no attempt is made to determine which temperature samples temporally belong to
                     * which EDA samples, initialize the input state with all temperature samples that have been passed
                     * to the fuction. */
                    p_input_state->temperature_accumulator = temperature_samples_sum;
                    p_input_state->temperature_count = temperature_signal_samples.count;
                } else {
                    p_input_state->temperature_accumulator = 0;
                    p_input_state->temperature_count = 0;
                }
            }
        }
    }

    return ERR_SUCCESS;
}

/* Calculates the EDA resistances from the measured positive and negative EDA samples and resistance scaling result. */
static void calculate_eda(uint32_t measurement_positive, uint32_t measurement_negative, uint32_t short_positive,
                          uint32_t short_negative, uint32_t reference_positive, uint32_t reference_negative,
                          uint32_t reference_resistance, float *p_resistance_positive, float *p_resistance_negative)
{
    *p_resistance_positive = ((float)measurement_positive - (float)short_positive) * (float)reference_resistance /
                             ((float)reference_positive - (float)short_positive);
    *p_resistance_negative = ((float)measurement_negative - (float)short_negative) * (float)reference_resistance /
                             ((float)reference_negative - (float)short_negative);
}

/* Returns ::TRUE when a recalibration is required due to temperature change and ::FALSE otherwise. */
static uint8_t is_recalibration_required(as7058_eda_scaling_result_t scaling_result,
                                         uint32_t temperature_delta_threshold, uint32_t temperature)
{
    if (0 == scaling_result.temperature_adc) {
        /* Always return FALSE when no reference temperature is known. */
        return FALSE;
    }

    int64_t reference_temp_adc = (int64_t)scaling_result.temperature_adc;
    int64_t temp_delta_threshold_adc = (int64_t)temperature_delta_threshold;

    if (((int64_t)temperature < (reference_temp_adc - temp_delta_threshold_adc)) ||
        ((int64_t)temperature > (reference_temp_adc + temp_delta_threshold_adc))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*! Prepares the global variables for the start of a new processing session. */
static err_code_t reset_processing_state(void)
{
    g_input_state.eda_positive_accumulator = 0;
    g_input_state.eda_negative_accumulator = 0;
    g_input_state.eda_total_count = 0;
    g_input_state.eda_total_drop_count = 0;
    g_input_state.temperature_accumulator = 0;
    g_input_state.temperature_count = 0;
    g_last_temperature = 0;
    g_last_temperature_valid = FALSE;
    M_CHECK_SUCCESS(FIFO_Reset(&g_input_queue));
    M_CHECK_SUCCESS(FIFO_Reset(&g_output_queue));

    return ERR_SUCCESS;
}

/******************************************************************************
 *                             GLOBAL FUNCTIONS                               *
 ******************************************************************************/

err_code_t as7058_eda_app_initialize(void)
{
    g_config_valid = FALSE;
    M_CHECK_SUCCESS(reset_processing_state());

    g_state = AS7058_EDA_APP_STATE_CONFIGURATION;

    return ERR_SUCCESS;
}

err_code_t as7058_eda_app_configure(const void *p_config, uint8_t size)
{
    M_CHECK_STATE(AS7058_EDA_APP_STATE_CONFIGURATION);
    M_CHECK_NULL_POINTER(p_config);
    M_CHECK_SIZE(sizeof(as7058_eda_app_configuration_t), size);

    memcpy((void *)&g_config, p_config, sizeof(as7058_eda_app_configuration_t));

    if (0 == g_config.scaling_result.ref_resistor || 0 == g_config.scaling_result.ref_temperature_adc) {
        /* These values are always non-zero in the Chip Library-provided EDA scaling results. The configuration data
         * does not contain plausible data if one of these fields is zero. */
        g_config_valid = FALSE;
    } else if (0 == g_config.eda_avg_num) {
        /* The number of samples to average for each calculation input needs to be at least one. */
        g_config_valid = FALSE;
    } else {
        g_config_valid = TRUE;
    }

    return ERR_SUCCESS;
}

err_code_t as7058_eda_app_start(const uint32_t *p_signal_sample_periods_us, uint8_t signal_num,
                                uint32_t acc_sample_period_us)
{
    M_UNUSED_PARAM(p_signal_sample_periods_us);
    M_UNUSED_PARAM(acc_sample_period_us);

    M_CHECK_STATE(AS7058_EDA_APP_STATE_CONFIGURATION);
    if (!g_config_valid) {
        /* as7058_eda_app_configure has not been called or has not been provided a valid configuration. */
        return ERR_CONFIG;
    }

    if (signal_num != AS7058_EDA_APP_SIGNAL_NUM) {
        /* Invalid signal number passed to function. */
        return ERR_ARGUMENT;
    }

    M_CHECK_SUCCESS(reset_processing_state());

    /* eda_total_drop_count is set to twice the configured number of samples to drop to avoid that the first samples are
     * dropped when as7058_eda_app_set_input/process_samples is called for the first time in a processing session. */
    g_input_state.eda_total_drop_count = g_config.eda_drop_num * 2;

    g_state = AS7058_EDA_APP_STATE_PROCESSING;

    return ERR_SUCCESS;
}

err_code_t as7058_eda_app_set_input(bio_signal_samples_type_t signal_samples_type,
                                    const bio_signal_samples_t *p_signal_samples,
                                    const agc_status_t *const *pp_agc_statuses, uint8_t signal_num,
                                    const vs_acc_data_t *p_acc_samples, uint8_t acc_sample_num,
                                    bio_execution_status_t *p_result)
{
    M_UNUSED_PARAM(pp_agc_statuses);
    M_UNUSED_PARAM(p_acc_samples);
    M_UNUSED_PARAM(acc_sample_num);

    M_CHECK_STATE(AS7058_EDA_APP_STATE_PROCESSING);

    if (signal_samples_type != AS7058_EDA_APP_SIGNAL_DATA_TYPE) {
        /* Invalid signal samples type passed to function. */
        return ERR_ARGUMENT;
    }

    if (signal_num != AS7058_EDA_APP_SIGNAL_NUM) {
        /* Invalid signal number passed to function. */
        return ERR_ARGUMENT;
    }

    M_CHECK_NULL_POINTER(p_result);

    const bio_signal_samples_t *p_eda_signal_samples = p_signal_samples + AS7058_EDA_APP_SIGNAL_EDA_ALTERNATING;
    const bio_signal_samples_t *p_temperature_signal_samples = p_signal_samples + AS7058_EDA_APP_SIGNAL_TEMPERATURE;

    M_CHECK_NULL_POINTER(p_signal_samples);
    M_CHECK_NULL_POINTER(p_eda_signal_samples->samples.p_i32);
    M_CHECK_NULL_POINTER(p_temperature_signal_samples->samples.p_i32);

    M_CHECK_SUCCESS(process_samples(&g_input_state, *p_eda_signal_samples, *p_temperature_signal_samples,
                                    g_config.eda_avg_num, g_config.eda_drop_num, &g_input_queue));

    uint32_t input_num;
    M_CHECK_SUCCESS(FIFO_GetItemCount(&g_input_queue, &input_num));
    if (input_num > 0) {
        *p_result = BIO_EXECUTION_STATUS_EXECUTABLE;
    } else {
        *p_result = BIO_EXECUTION_STATUS_NOT_EXECUTABLE;
    }

    return ERR_SUCCESS;
}

err_code_t as7058_eda_app_execute(bio_output_status_t *p_result)
{
    M_CHECK_STATE(AS7058_EDA_APP_STATE_PROCESSING);

    M_CHECK_NULL_POINTER(p_result);

    while (TRUE) {
        struct as7058_eda_app_calculation_input input;
        err_code_t result = FIFO_Get(&g_input_queue, &input);
        if (ERR_FIFO == result) {
            /* Queue is empty. */
            break;
        }
        M_CHECK_SUCCESS(result);

        if (input.temperature_valid) {
            /* Update stored temperature with temperature value provided via calculation input. */
            g_last_temperature = input.temperature;
            g_last_temperature_valid = TRUE;
        }

        /* Calculate EDA magnitude and phase. */
        float resistance_positive;
        float resistance_negative;
        calculate_eda(input.eda_positive, input.eda_negative, g_config.scaling_result.short_p,
                      g_config.scaling_result.short_n, g_config.scaling_result.resistor_p,
                      g_config.scaling_result.resistor_n, g_config.scaling_result.ref_resistor, &resistance_positive,
                      &resistance_negative);

        if (!(isgreaterequal(resistance_positive, -2000000000.0f) && islessequal(resistance_positive, 2000000000.0f)) ||
            !(isgreaterequal(resistance_negative, -2000000000.0f) && islessequal(resistance_negative, 2000000000.0f))) {
            /* Resulting magnitude or phase values can not be represented using integers. */
            return ERR_DATA;
        }

        /* Generate output. */
        as7058_eda_app_output_t output;
        output.resistance = (int32_t)((resistance_positive + resistance_negative) / 2.0f);
        output.resistance_positive = (int32_t)resistance_positive;
        output.resistance_negative = (int32_t)resistance_negative;
        output.flags = 0;
        if (g_last_temperature_valid) {
            if (is_recalibration_required(g_config.scaling_result, g_config.temperature_delta_threshold,
                                          g_last_temperature)) {
                output.flags |= AS7058_EDA_APP_OUTPUT_FLAGS_RECALIBRATION_WARNING;
            }
        }
        M_CHECK_SUCCESS(FIFO_Put(&g_output_queue, &output));
    }

    uint32_t outputs_num;
    M_CHECK_SUCCESS(FIFO_GetItemCount(&g_output_queue, &outputs_num));
    if (0 == outputs_num) {
        *p_result = BIO_OUTPUT_STATUS_DATA_UNAVAILABLE;
    } else {
        *p_result = BIO_OUTPUT_STATUS_DATA_AVAILABLE;
    }

    return ERR_SUCCESS;
}

err_code_t as7058_eda_app_get_output(void *p_dest, uint16_t *p_size)
{
    M_CHECK_STATE(AS7058_EDA_APP_STATE_PROCESSING);

    M_CHECK_NULL_POINTER(p_dest);
    M_CHECK_NULL_POINTER(p_size);

    if (*p_size < sizeof(as7058_eda_app_output_t)) {
        /* Size of destination buffer is insufficient. */
        return ERR_SIZE;
    }

    err_code_t result = FIFO_Get(&g_output_queue, p_dest);

    if (ERR_FIFO == result) {
        /* Queue is empty. */
        return ERR_NO_DATA;
    }
    M_CHECK_SUCCESS(result);

    *p_size = sizeof(as7058_eda_app_output_t);

    return ERR_SUCCESS;
}

err_code_t as7058_eda_app_stop(void)
{
    M_CHECK_STATE_NOT(AS7058_EDA_APP_STATE_UNINITIALIZED);

    g_state = AS7058_EDA_APP_STATE_CONFIGURATION;

    return ERR_SUCCESS;
}

err_code_t as7058_eda_app_shutdown(void)
{
    g_state = AS7058_EDA_APP_STATE_UNINITIALIZED;

    return ERR_SUCCESS;
}
